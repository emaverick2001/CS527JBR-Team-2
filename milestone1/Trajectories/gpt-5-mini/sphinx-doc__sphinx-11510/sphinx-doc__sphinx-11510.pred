{"model_name_or_path": "GPT", "instance_id": "sphinx-doc__sphinx-11510", "model_patch": "diff --git a/sphinx/directives/other.py b/sphinx/directives/other.py\nindex 19f7c0a8d..872da71df 100644\n--- a/sphinx/directives/other.py\n+++ b/sphinx/directives/other.py\n@@ -376,7 +376,72 @@ class Include(BaseInclude, SphinxDirective):\n         rel_filename, filename = self.env.relfn2path(self.arguments[0])\n         self.arguments[0] = filename\n         self.env.note_included(filename)\n-        return super().run()\n+\n+        # Monkeypatch docutils.io.FileInput.read/readlines temporarily so that\n+        # extensions listening to 'source-read' can modify the content of\n+        # included files.  BaseInclude.run() uses FileInput.read()/readlines()\n+        # to obtain the content, so wrapping those lets us emit the event\n+        # and replace the raw text before docutils parses it.\n+        try:\n+            import docutils.io as _docio\n+        except Exception:\n+            return super().run()\n+\n+        _orig_read = getattr(_docio.FileInput, 'read', None)\n+        _orig_readlines = getattr(_docio.FileInput, 'readlines', None)\n+\n+        env = self.env\n+        path_arg = None\n+        try:\n+            # try to compute the path that will be used for the include\n+            # so we can pass a reasonable docname to the event handlers\n+            path_arg = _docio.FileInput(source_path=None)  # dummy to introspect\n+        except Exception:\n+            path_arg = None\n+\n+        def _wrap_read(self_file, *args, **kwargs):\n+            content = _orig_read(self_file, *args, **kwargs) if _orig_read else ''\n+            try:\n+                docname = env.path2doc(self_file.source) if hasattr(env, 'path2doc') else None\n+            except Exception:\n+                docname = None\n+            arg = [content]\n+            try:\n+                env.events.emit('source-read', docname or getattr(self_file, 'source', None), arg)\n+                return arg[0]\n+            except Exception:\n+                return content\n+\n+        def _wrap_readlines(self_file, *args, **kwargs):\n+            lines = _orig_readlines(self_file, *args, **kwargs) if _orig_readlines else []\n+            content = ''.join(lines)\n+            try:\n+                docname = env.path2doc(self_file.source) if hasattr(env, 'path2doc') else None\n+            except Exception:\n+                docname = None\n+            arg = [content]\n+            try:\n+                env.events.emit('source-read', docname or getattr(self_file, 'source', None), arg)\n+                new_content = arg[0]\n+                # preserve newline behavior similar to FileInput.readlines\n+                return new_content.splitlines(True)\n+            except Exception:\n+                return lines\n+\n+        # apply monkeypatch\n+        if _orig_read:\n+            _docio.FileInput.read = _wrap_read\n+        if _orig_readlines:\n+            _docio.FileInput.readlines = _wrap_readlines\n+\n+        try:\n+            return super().run()\n+        finally:\n+            # restore original functions\n+            if _orig_read:\n+                _docio.FileInput.read = _orig_read\n+            if _orig_readlines:\n+                _docio.FileInput.readlines = _orig_readlines\n \n \n def setup(app: Sphinx) -> dict[str, Any]:\n"}